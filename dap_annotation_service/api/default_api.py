# coding: utf-8

"""
    Nesta Annotation Service

    DBpedia Spotlight Annotation service for large datasets.  Please refer to the <a href=\"https://github.com/nestauk/dap_dv_backends/tree/dev/src/services/annotation\" target=\"_blank\">docs</a> for a complete guide on how to use the service.  # noqa: E501

    OpenAPI spec version: 0.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from dap_annotation_service.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def es_get(self, index, **kwargs):  # noqa: E501
        """Annotate data being hosted on an ElasticSearch index  # noqa: E501

        This endpoint expects to be able to access the specified ES index and domain. Users should also specify the field contained within the ES doc to be tused as input for the annotation process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.es_get(index, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str index: Index on which the text to be annotated is hosted (required)
        :param str domain: ElasticSearch domain on which the index is hosted
        :param bool include_meta_data: Whether to include metadata about the annotation process along with annotation results
        :param str new_field: Name of key corresponding to newly created annotation field
        :param float workers: Number of EC2 instances created to handle annotation process
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.es_get_with_http_info(index, **kwargs)  # noqa: E501
        else:
            (data) = self.es_get_with_http_info(index, **kwargs)  # noqa: E501
            return data

    def es_get_with_http_info(self, index, **kwargs):  # noqa: E501
        """Annotate data being hosted on an ElasticSearch index  # noqa: E501

        This endpoint expects to be able to access the specified ES index and domain. Users should also specify the field contained within the ES doc to be tused as input for the annotation process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.es_get_with_http_info(index, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str index: Index on which the text to be annotated is hosted (required)
        :param str domain: ElasticSearch domain on which the index is hosted
        :param bool include_meta_data: Whether to include metadata about the annotation process along with annotation results
        :param str new_field: Name of key corresponding to newly created annotation field
        :param float workers: Number of EC2 instances created to handle annotation process
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['index', 'domain', 'include_meta_data', 'new_field', 'workers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method es_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'index' is set
        if ('index' not in params or
                params['index'] is None):
            raise ValueError("Missing the required parameter `index` when calling `es_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'index' in params:
            query_params.append(('index', params['index']))  # noqa: E501
        if 'domain' in params:
            query_params.append(('domain', params['domain']))  # noqa: E501
        if 'include_meta_data' in params:
            query_params.append(('includeMetaData', params['include_meta_data']))  # noqa: E501
        if 'new_field' in params:
            query_params.append(('newField', params['new_field']))  # noqa: E501
        if 'workers' in params:
            query_params.append(('workers', params['workers']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/es', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def progress_id_get(self, id, **kwargs):  # noqa: E501
        """Get progress for a given annotation using its ID  # noqa: E501

        Using the ID provided by the response to an annotation request, you can use this endpoint to retrieve information about the progress of the annotation. When the annotation has finished, you should also recieve an email notifying you of the fact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID provided by the annotation request's response (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.progress_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.progress_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def progress_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get progress for a given annotation using its ID  # noqa: E501

        Using the ID provided by the response to an annotation request, you can use this endpoint to retrieve information about the progress of the annotation. When the annotation has finished, you should also recieve an email notifying you of the fact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: ID provided by the annotation request's response (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method progress_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `progress_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/progress/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def s3_get(self, field, s3_input_uri, s3_output_uri, **kwargs):  # noqa: E501
        """Annotate data being hosted on an AWS S3 bucket  # noqa: E501

        The endpoint expects an input S3 URI and output S3 URI. The dataset to be annotated must adhere to a required schema, which is documented below.  The input dataset must be in `json` format, with the root level object being an array. Each item in the array must be an object, with an optional id field, and the `field` key that you speficy in the request body. For example, the following is a dataset which conforms to the correct input schema:  <pre><code>[  { \"id\": 1, \"description\": \"This is some test data to be annotated.\" },  { \"id\": 2, \"description\": \"This is some more test date to be annotated.\" } ]</code></pre>  The API will perform a number of checks to ensure that the data is available and that the dataset and request is well formed. However, please ensure that the input S3 URI exists, and that the output S3 URI does *not* exist, as the service will not overwrite any existing data on S3.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.s3_get(field, s3_input_uri, s3_output_uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str field: Field for the value being annotated. (required)
        :param str s3_input_uri: URI for bucket containing input dataset (required)
        :param str s3_output_uri: URI for output bucket. Please ensure this bucket does not already exist (required)
        :param str id_field: Field corresponding to ids for the documents being annotated. If null, these IDs will be generated using the ElasticSearch API.
        :param str output_format: Output type, whether the root data type should be an aray or an object
        :param str output_processor: Final type of output. Different types are described in detail in the docs.
        :param bool include_meta_data: Whether to include metadata about the annotation process along with annotation results
        :param str new_field: Name of key corresponding to newly created annotation field
        :param float workers: Number of EC2 instances created to handle annotation process
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.s3_get_with_http_info(field, s3_input_uri, s3_output_uri, **kwargs)  # noqa: E501
        else:
            (data) = self.s3_get_with_http_info(field, s3_input_uri, s3_output_uri, **kwargs)  # noqa: E501
            return data

    def s3_get_with_http_info(self, field, s3_input_uri, s3_output_uri, **kwargs):  # noqa: E501
        """Annotate data being hosted on an AWS S3 bucket  # noqa: E501

        The endpoint expects an input S3 URI and output S3 URI. The dataset to be annotated must adhere to a required schema, which is documented below.  The input dataset must be in `json` format, with the root level object being an array. Each item in the array must be an object, with an optional id field, and the `field` key that you speficy in the request body. For example, the following is a dataset which conforms to the correct input schema:  <pre><code>[  { \"id\": 1, \"description\": \"This is some test data to be annotated.\" },  { \"id\": 2, \"description\": \"This is some more test date to be annotated.\" } ]</code></pre>  The API will perform a number of checks to ensure that the data is available and that the dataset and request is well formed. However, please ensure that the input S3 URI exists, and that the output S3 URI does *not* exist, as the service will not overwrite any existing data on S3.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.s3_get_with_http_info(field, s3_input_uri, s3_output_uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str field: Field for the value being annotated. (required)
        :param str s3_input_uri: URI for bucket containing input dataset (required)
        :param str s3_output_uri: URI for output bucket. Please ensure this bucket does not already exist (required)
        :param str id_field: Field corresponding to ids for the documents being annotated. If null, these IDs will be generated using the ElasticSearch API.
        :param str output_format: Output type, whether the root data type should be an aray or an object
        :param str output_processor: Final type of output. Different types are described in detail in the docs.
        :param bool include_meta_data: Whether to include metadata about the annotation process along with annotation results
        :param str new_field: Name of key corresponding to newly created annotation field
        :param float workers: Number of EC2 instances created to handle annotation process
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['field', 's3_input_uri', 's3_output_uri', 'id_field', 'output_format', 'output_processor', 'include_meta_data', 'new_field', 'workers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s3_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'field' is set
        if ('field' not in params or
                params['field'] is None):
            raise ValueError("Missing the required parameter `field` when calling `s3_get`")  # noqa: E501
        # verify the required parameter 's3_input_uri' is set
        if ('s3_input_uri' not in params or
                params['s3_input_uri'] is None):
            raise ValueError("Missing the required parameter `s3_input_uri` when calling `s3_get`")  # noqa: E501
        # verify the required parameter 's3_output_uri' is set
        if ('s3_output_uri' not in params or
                params['s3_output_uri'] is None):
            raise ValueError("Missing the required parameter `s3_output_uri` when calling `s3_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'field' in params:
            query_params.append(('field', params['field']))  # noqa: E501
        if 's3_input_uri' in params:
            query_params.append(('s3_input_uri', params['s3_input_uri']))  # noqa: E501
        if 's3_output_uri' in params:
            query_params.append(('s3_output_uri', params['s3_output_uri']))  # noqa: E501
        if 'id_field' in params:
            query_params.append(('idField', params['id_field']))  # noqa: E501
        if 'output_format' in params:
            query_params.append(('output_format', params['output_format']))  # noqa: E501
        if 'output_processor' in params:
            query_params.append(('output_processor', params['output_processor']))  # noqa: E501
        if 'include_meta_data' in params:
            query_params.append(('includeMetaData', params['include_meta_data']))  # noqa: E501
        if 'new_field' in params:
            query_params.append(('newField', params['new_field']))  # noqa: E501
        if 'workers' in params:
            query_params.append(('workers', params['workers']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/s3', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def status_get(self, **kwargs):  # noqa: E501
        """Get current status of Annotation server  # noqa: E501

        Returns the status of the current Annotation server. Includes information on provisioned EC2 instances for ongoing annotations. Also includes information about past annotations, and the progess of ongoing annotations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.status_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.status_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get current status of Annotation server  # noqa: E501

        Returns the status of the current Annotation server. Includes information on provisioned EC2 instances for ongoing annotations. Also includes information about past annotations, and the progess of ongoing annotations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
